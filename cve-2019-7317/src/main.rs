mod bindings;

use std::path::PathBuf;

use crate::bindings::libpng::*;
use libafl::corpus::{InMemoryCorpus, OnDiskCorpus};
use libafl::events::{SimpleEventManager, SimpleRestartingEventManager};
use libafl::executors::{ExitKind, InProcessForkExecutor};
use libafl::feedbacks::{CrashFeedback, MaxMapFeedback, TimeoutFeedback};
use libafl::inputs::BytesInput;
use libafl::monitors::SimpleMonitor;
use libafl::mutators::{havoc_mutations, HavocScheduledMutator};
use libafl::observers::{ConstMapObserver, HitcountsMapObserver, TimeObserver};
use libafl::schedulers::QueueScheduler;
use libafl::stages::StdMutationalStage;
use libafl::state::StdState;
use libafl::{feedback_or, feedback_or_fast, Fuzzer, StdFuzzer};
use libafl_bolts::{
    nonnull_raw_mut,
    rands::StdRand,
    shmem::{ShMemProvider, StdShMemProvider},
    tuples::tuple_list,
    AsSliceMut,
};
use libafl_targets::{EDGES_MAP, EDGES_MAP_DEFAULT_SIZE, EDGES_MAP_PTR};

fn main() {
    let mut harness = |input: &BytesInput| ExitKind::Ok;

    let mut shmem_provider = StdShMemProvider::new().unwrap();
    let mut shmem = shmem_provider.new_shmem(EDGES_MAP_DEFAULT_SIZE).unwrap();

    unsafe {
        EDGES_MAP_PTR = shmem.as_slice_mut().as_mut_ptr();
    }

    let edges_observer = HitcountsMapObserver::new(unsafe {
        ConstMapObserver::from_mut_ptr("edges", nonnull_raw_mut!(EDGES_MAP))
    });
    let time_observer = TimeObserver::new("time");

    let map_feedback = MaxMapFeedback::new(&edges_observer);

    let mut objective = feedback_or_fast!(CrashFeedback::new(), TimeoutFeedback::new());

    let mut feedback = feedback_or_fast!(CrashFeedback::new(), map_feedback);

    let mut state = StdState::new(
        StdRand::new(),
        InMemoryCorpus::new(),
        OnDiskCorpus::new(PathBuf::from("./crashes")).unwrap(),
        &mut feedback,
        &mut objective,
    );

    let monitor = SimpleMonitor::new(|stats| {
        println!("{stats}");
    });

    let mut manager = SimpleRestartingEventManager::launch(monitor, &mut shmem_provider);

    let scheduler = QueueScheduler::new();

    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);

    let mut executor = InProcessForkExecutor::new(
        &mut harness,
        tuple_list!(edges_observer, time_observer),
        &mut fuzzer,
        &mut state,
        &mut manager,
        core::time::Duration::from_millis(5000),
        shmem_provider,
    );

    let mutator = HavocScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

    fuzzer
        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut manager)
        .expect("error in the fuzzing loop");
}
