mod bindings;

use std::ffi::c_void;
use std::path::PathBuf;

use crate::bindings::libpng::*;
use libafl::corpus::{HasCurrentCorpusId, InMemoryCorpus, OnDiskCorpus};
use libafl::events::SimpleRestartingEventManager;
use libafl::executors::{ExitKind, InProcessForkExecutor};
use libafl::feedbacks::{CrashFeedback, MaxMapFeedback, TimeoutFeedback};
use libafl::generators::RandBytesGenerator;
use libafl::inputs::{BytesInput, HasTargetBytes};
use libafl::monitors::SimplePrintingMonitor;
use libafl::mutators::{havoc_mutations, HavocScheduledMutator};
use libafl::observers::{ConstMapObserver, HitcountsMapObserver, TimeObserver};
use libafl::schedulers::QueueScheduler;
use libafl::stages::StdMutationalStage;
use libafl::state::StdState;
use libafl::{feedback_or_fast, nonzero, Fuzzer, StdFuzzer};
use libafl_bolts::shmem::StdShMem;
use libafl_bolts::HasLen;
use libafl_bolts::{
    nonnull_raw_mut,
    rands::StdRand,
    shmem::{ShMemProvider, StdShMemProvider},
    tuples::tuple_list,
    AsSliceMut,
};
use libafl_targets::{EDGES_MAP, EDGES_MAP_DEFAULT_SIZE, EDGES_MAP_PTR};

type MyInput = BytesInput;
type MyMonitor = SimplePrintingMonitor;
type MyRand = StdRand;
type MyCorpus = InMemoryCorpus<MyInput>;
type MySolutionsCorpus = OnDiskCorpus<MyInput>;
type MyState = StdState<MyCorpus, MyInput, MyRand, MySolutionsCorpus>;
type MyShMemProvider = StdShMemProvider;
type MyShMem = StdShMem;
type MyEventManager =
    SimpleRestartingEventManager<MyInput, MyMonitor, MyState, MyShMem, MyShMemProvider>;

fn main() {
    let mut harness = |input: &BytesInput| {
        // convert the input to a byte array
        if input.len() < 8 {
            return ExitKind::Ok;
        }

        let mut image: png_image = unsafe { std::mem::zeroed() };
        image.version = PNG_IMAGE_VERSION;
        let image_ptr: *mut png_image = &raw mut image;

        let data: &[u8] = &input.clone().into_inner();
        let ptr: *const u8 = data.as_ptr();
        let len: usize = data.len();

        unsafe {
            if png_image_begin_read_from_memory(image_ptr, ptr as *mut c_void, len) != 0 {
                png_image_free(image_ptr);
            }
        }

        ExitKind::Ok
    };

    let mut shmem_provider = MyShMemProvider::new().unwrap();
    let mut shmem = shmem_provider.new_shmem(EDGES_MAP_DEFAULT_SIZE).unwrap();

    unsafe {
        EDGES_MAP_PTR = shmem.as_slice_mut().as_mut_ptr();
    }

    let edges_observer = HitcountsMapObserver::new(unsafe {
        ConstMapObserver::from_mut_ptr("edges", nonnull_raw_mut!(EDGES_MAP))
    });
    let time_observer = TimeObserver::new("time");

    let map_feedback = MaxMapFeedback::new(&edges_observer);

    let mut objective = feedback_or_fast!(CrashFeedback::new(), TimeoutFeedback::new());

    let mut feedback = feedback_or_fast!(CrashFeedback::new(), map_feedback);

    let monitor = MyMonitor::new();

    let (mut state, mut manager) = match MyEventManager::launch(monitor, &mut shmem_provider) {
        Ok((state, manager)) => (state.unwrap(), manager),
        Err(libafl::Error::ShuttingDown) => return,
        Err(_e) => panic!("failed to launch SimpleRestartingEventManager"),
    };

    let scheduler = QueueScheduler::new();

    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);

    let mut executor = InProcessForkExecutor::new(
        &mut harness,
        tuple_list!(edges_observer, time_observer),
        &mut fuzzer,
        &mut state,
        &mut manager,
        core::time::Duration::from_millis(5000),
        shmem_provider,
    )
    .expect("failed to create the executor");

    let mut generator = RandBytesGenerator::new(nonzero!(32));
    state
        .generate_initial_inputs(&mut fuzzer, &mut executor, &mut generator, &mut manager, 8)
        .expect("failed to generate initial input");

    let mutator = HavocScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

    fuzzer
        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut manager)
        .expect("error in the fuzzing loop");
}
